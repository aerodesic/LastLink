#ifdef NOTUSED
    # Read register from SPI port
    def read_register(self, address):
        value = int.from_bytes(self._spi_transfer(address & 0x7F), 'big')
        # print("%02x from %02x" % (value, address))
        return value

    # Write register to SPI port
    def write_register(self, address, value):
        # print("write %02x to %02x" % (value, address))
        self._spi_transfer(address | 0x80, value)

    def _spi_transfer(self, address, value=0):
        response = bytearray(1)
        self._ss.value(0)
        self._spi.write(bytes([address]))
        self._spi.write_readinto(bytes([value]), response)
        self._ss.value(1)
        return response

    # Read block of data from SPI port
    def read_buffer(self, address, length):
        try:
            response = bytearray(length)
            self._ss.value(0)
            self._spi.write(bytes([address & 0x7F]))
            self._spi.readinto(response)
            self._ss.value(1)

        except:
            # No room.  gc now
            gc.collect()
            response = None

        return response

    # Write block of data to SPI port
    def write_buffer(self, address, buffer, size):
        self._ss.value(0)
        self._spi.write(bytes([address | 0x80]))
        self._spi.write(memoryview(buffer)[0:size])
        self._ss.value(1)

    def attach_interrupt(self, dio, edge, callback):
        # if self._debug:
        #    print("attach_interrupt dio %d rising %s with callback %s" % (dio, edge, callback))

        if dio < 0 or dio >= len(self._dio_table):
            raise Exception("DIO %d out of range (0..%d)" % (dio, len(self._dio_table) - 1))

        edge = Pin.IRQ_RISING if edge else Pin.IRQ_FALLING
        self._dio_table[dio].irq(handler=callback, trigger=edge if callback else 0)

    # Enwrap the packet with a class object for the particular message type
    def wrap_packet(self, data, rssi=None):
        return self.get_protocol_wrapper(data[_HEADER_PROTOCOL[0]])(load=data, rssi=rssi)
        
    # Duplicate packet with new private data
    def dup_packet(self, packet):
        return self.wrap_packet(bytearray(packet.data()), rssi=packet.rssi())

    def onReceive(self, data, crc_ok, rssi):
        if crc_ok:
            packet = self.wrap_packet(data, rssi)

            nexthop = packet.nexthop()

            if self._debug:
                print("Received: %s" % (str(packet)))

            # In promiscuous, deliver to receiver so it can handle it (but not process it)
            if self._promiscuous:
                packet_copy = self.dup_packet(packet)
                packet_copy.promiscuous(True)
                self.put_receive_packet(packet_copy)

            if nexthop == BROADCAST_ADDRESS or nexthop == self.address:
                self._packet_received += 1
                # To us or broadcasted
                packet.process(self)

            else:
                # It is non processed
                self._packet_ignored += 1

        else:
            self._packet_errors_crc += 1


    def receive_packet(self):
        gc.collect()
        return self._receive_queue.get()

    def put_receive_packet(self, packet):
        self._receive_queue.put(packet)
        gc.collect()

    # Finished transmitting - see if we can transmit another
    # If we have another packet, return it to caller.
    def onTransmit(self):
        # if self._debug:
        #    print("onTransmit complete")

        self._packet_transmitted += 1

        # Delete top packet in queue
        packet = self._transmit_queue.get(wait=0)
        del packet

        # Return head of queue if one exists
        packet = self._transmit_queue.head()

        gc.collect()

        return packet.data() if packet else None

    def _create_sequence_number(self):
        with self._hwmp_sequence_lock:
            self._hwmp_sequence_number += 1
            return self._hwmp_sequence_number

    # A packet with a source and destination is ready to transmit.
    # Label the from address and if no to address, attempt to route
    # If ttl is true, decrease ttl and discard packet if 0
    def send_packet(self, packet, ttl=False):
        if ttl and packet.ttl(packet.ttl() - 1) == 0:
            # Packet has expired
            if self._debug:
                print("Expired: %s" % str(packet))
        else:
            # Label packets as coming from us
            packet.previous(self.address)
            # print("%s: set previous to %d" % (str(packet), self.address))

            # Label as originating here if no previous assigned source address
            if packet.source() == NULL_ADDRESS:
                packet.source(self.address)
                # print("%s: set source to %d" % (str(packet), self.address))

            # If the nexthop is NULL, then we compute next hop based on route table.
            # If no route table, create pending NULL route and cache packet for later retransmission.
            if packet.nexthop() == NULL_ADDRESS:
                with self._route_lock:
                    # Look up the route to the destination
                    route = self.find_route(packet.target())

                    # If no route, create a dummy route and queue the results
                    if route == None:
                        # Unknown route.  Create a NULL route awaiting RouteAnnounce
                        route = self.update_route(target=packet.target(), nexthop=NULL_ADDRESS, sequence=self._create_sequence_number(), force=True)

                        # Save packet in route for later delivery
                        route.put_pending_packet(packet)

                        if self._debug:
                            print("Routing %s" % str(packet))
                        request = RouteRequest(target=packet.target(), previous=self.address, source=self.address, sequence=route.sequence(), metric=1, gateway_flag=self._gateway)

                        # This will queue repeats of this request until cancelled
                        route.set_pending_routerequest(request)

                    elif route.nexthop() == NULL_ADDRESS:
                        # We still have a pending route, so append packet to queue only.
                        request = None
                        route.put_pending_packet(packet)

                    else:
                        # Label the destination for the packet
                        packet.nexthop(route.nexthop())
                        request = packet

                # Transmit the request if we created one or else the actual packet
                packet = request

            if packet:
                #
                # TODO: we may need another method to restart transmit queue other than looking
                # and transmit queue length.  A 'transmitting' flag (protected by meshlock) that
                # is True if transmitting of packet is in progress.  Cleared on onTransmit when
                # queue has become empty.
                #
                # This may need to be implemented to allow stalling transmission for windows of
                # reception.  A timer will then restart the queue if items remain within it.
                #
                # if self._debug:
                #     print("sending: %s" % str(packet))

                with self._meshlock:
                    # print("Appending to queue: %s" % packet.decode())
                    self._transmit_queue.put(packet)
                    if len(self._transmit_queue) == 1:
                        self.transmit_packet(packet.data())
                        if self._debug:
                            print("Transmitted: %s" % str(packet))

    # A thread to check all routes and those with resend the packets for those with retry requests
    def _retry_routerequests(self, thread, timeout):
        while thread.running:
            sleep(timeout)
            with self._route_lock:
                # Go through all routes looking for those with pending requests.
                for target in list(self._routes):
                    route = self._routes[target]
                    # If route is expired, remove it
                    if route.is_expired():
                        # Clean up route
                        del(self._routes[target])

                    # Otherwise if it has a pending request, resend it
                    else:
                        packet = route.get_pending_routerequest()
                        if packet:
                            if self._debug:
                                print("Retry route request %s" % str(packet))
                            self.send_packet(packet)

    def stop(self):
        # Stop announce if running
        if self._announce_thread:
            self._announce_thread.stop()
            self._announce_thread.wait()
            self._announce_thread = None

        if self._retry_routerequest_thread != None:
            self._retry_routerequest_thread.stop()
            self._retry_routerequest_thread.wait()
            self._retry_routerequest_thread = None

        super(MeshNet, self).stop()

        # Shut down power
        self.set_power(False)

        print("MeshNet handler close called")
        # Close DIO interrupts
        for dio in self._dio_table:
            dio.irq(handler=None, trigger=0)

        # Close SPI channel if opened
        if self._spi:
            self._spi.deinit()
            self._spi = None

    def set_power(self, power=True):
        # print("set_power %s" % power)

        if power != self._power:
            self._power = power

            # Call base class
            super(MeshNet, self).set_power(power)

    def __del__(self):
        self.stop()

    def dump(self):
        item = 0
        for reg in range(0x43):
            print("%02x: %02x" % (reg, self.read_register(reg)), end="    " if item != 7 else "\n")
            item = (item + 1) % 8
        print("")
#endif
